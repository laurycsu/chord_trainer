<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<title>Chord Trainer ‚Äî Guitar & Piano (+ Riffs, Metronome, Preview)</title>
<style>
  :root{
    --bg1:#3b1e75; --bg2:#1e1b4b; --card:rgba(255,255,255,.08); --card2:rgba(255,255,255,.14);
    --text:#fff; --muted:rgba(255,255,255,.75);
    --accent:#ffd166; --purple:#7c3aed;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif; color:var(--text);
       background:linear-gradient(180deg,var(--bg1),var(--bg2)) fixed;}
  .container{max-width:1100px; margin:0 auto; padding:24px 16px}
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:16px}
  h1{font-size:clamp(20px,3vw,28px); margin:0; font-weight:700; letter-spacing:.2px}
  .row{display:grid; gap:16px}
  @media(min-width:860px){ .row.stats{grid-template-columns:repeat(3,1fr)} }
  .card{background:var(--card); border-radius:20px; padding:16px; backdrop-filter: blur(6px); box-shadow: 0 6px 24px rgba(0,0,0,.25)}
  .label{font-size:12px; color:var(--muted); margin-bottom:4px}
  .value{font-size:22px; font-weight:700}
  .sub{font-size:12px; color:var(--muted); margin-top:4px}
  .controls{display:flex; gap:10px; justify-content:center; margin-top:14px; flex-wrap:wrap}
  button{border:0; border-radius:16px; padding:10px 14px; color:#000; background:#fff; cursor:pointer; font-weight:600; box-shadow:0 6px 16px rgba(0,0,0,.2)}
  button.ghost{background:var(--card2); color:var(--text)}
  button.chip{padding:8px 10px; border-radius:999px; background:var(--card2); color:var(--text)}
  .main{display:grid; gap:18px}
  @media(min-width:980px){ .main{grid-template-columns:1fr 360px} }
  .topbar{display:flex; gap:8px; align-items:center}
  .spacer{flex:1}
  .progress-wrap{display:flex; flex-direction:column; align-items:center; gap:8px; padding-block:12px}
  .big{font-size:72px; font-weight:800}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:11px; opacity:.8}
  .grid2{display:grid; grid-template-columns:repeat(2,1fr); gap:12px}
  .count{font-size:26px; font-weight:800}
  details summary{cursor:pointer; color:var(--muted)}
  input[type=range]{width:100%}
  footer{margin-top:18px; text-align:center; font-size:12px; color:var(--muted)}
  .svg-wrap{display:flex; align-items:center; justify-content:center}

  /* riff strip */
  .riff-strip{display:flex; gap:6px; flex-wrap:wrap; justify-content:center; margin-top:8px}
  .riff-note{padding:6px 10px; border-radius:10px; background:#ffffff22; color:#fff; font-weight:700}
  .riff-note.active{background:var(--accent); color:#3b1e75}
  .mode-tag{font-size:12px; padding:3px 8px; border-radius:999px; background:#00000055; color:var(--accent); font-weight:700}

  /* metronome */
  .metro{display:flex; align-items:center; gap:10px}
  .blink{width:14px; height:14px; border-radius:50%; background:#ffffff33; box-shadow:0 0 0 0 rgba(0,0,0,0)}
  .blink.active{background:var(--accent); box-shadow:0 0 10px 2px rgba(255,209,102,.6)}

  /* preview */
  .preview{font-weight:800; padding:4px 10px; border-radius:12px; background:#00000055}
  .blurred{filter: blur(4px)}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Chord Trainer</h1>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
        <div class="card" style="display:flex; gap:6px; padding:6px">
          <button id="btnGuitar" class="chip" title="Guitar mode">üé∏ Guitar</button>
          <button id="btnPiano"  class="chip" title="Piano mode">üéπ Piano</button>
        </div>
        <div class="card" style="display:flex; gap:6px; padding:6px">
          <button id="btnChordOnly" class="chip" title="Chord only">Chord only</button>
          <button id="btnChordRiff" class="chip" title="Chord + Riff">Chord + Riff</button>
          <span id="riffTag" class="mode-tag" style="display:none"></span>
        </div>
        <div class="card metro" style="padding:6px 10px">
          <div class="blink" id="metroDot"></div>
          <div class="label" style="margin:0">Metronome</div>
          <div class="value" style="font-size:16px"><span id="bpmVal">90</span> bpm</div>
          <input id="bpmSlider" type="range" min="40" max="140" step="1" value="90" />
        </div>
        <button id="btnExport" class="ghost" title="Export CSV">Export CSV</button>
        <div class="card" style="display:flex; gap:6px; padding:6px; align-items:center">
          <button id="btnClick"   class="chip" title="Metronome click sound">üîä Click</button>
          <button id="btnCountIn" class="chip" title="3-2-1 Count-in">‚è±Ô∏è Count-in</button>
        </div>
      </div>
    </header>

    <div class="row stats">
      <div class="card">
        <div class="label">Session</div>
        <div class="value" id="vSession">0:00</div>
        <div class="sub" id="vSub">0 changes ‚Ä¢ 0.0 cpm</div>
      </div>
      <div class="card">
        <div class="label">Tempo (Chord phase)</div>
        <div class="value"><span id="vTempo">3</span>s / chord</div>
        <div class="sub">Use the slider to adjust</div>
      </div>
      <div class="card">
        <div class="label">Now</div>
        <div class="value">
          <span id="vNow">C</span> (<span id="vInstr">guitar</span>)
          <span style="margin-left:8px" class="label">Next:</span>
          <span id="nextChord" class="preview">G</span>
          <button id="togglePreview" class="chip" style="margin-left:8px">Preview: Show</button>
        </div>
        <div class="sub">Current chord & next chord preview</div>
      </div>
    </div>

    <div class="main" style="margin-top:16px">
      <div class="card">
        <div class="topbar">
          <button id="btnPrev" class="ghost" title="Previous (‚Üê)">‚óÄ</button>
          <div class="label">Practice</div>
          <div class="spacer"></div>
          <div class="kbd">Space: Start/Pause ‚Ä¢ S: Stop ‚Ä¢ ‚Üê ‚Üí: Step (paused)</div>
          <button id="btnNext" class="ghost" title="Next (‚Üí)">‚ñ∂</button>
        </div>

        <div class="progress-wrap">
          <div id="progressSvg" class="svg-wrap"></div>
          <div class="big" id="bigChord">C</div>
          <div id="diagram" class="svg-wrap" style="margin-top:6px"></div>

          <!-- Riff UI -->
          <div id="riffWrap" style="display:none; width:100%; margin-top:6px">
            <div class="label" style="text-align:center">Riff (auto-transposed)</div>
            <div id="riffStrip" class="riff-strip"></div>
            <div id="riffGraphic" class="svg-wrap" style="margin-top:8px"></div>
          </div>

          <div id="countInBadge" style="position:relative; height:0">
            <div id="countInNum" style="position:absolute; right:6px; top:-6px; font-size:46px; font-weight:900; opacity:.6; display:none">3</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">Start</button>
          <button id="btnPause" class="ghost">Pause</button>
          <button id="btnStop"  class="ghost">Stop</button>
        </div>

        <div style="margin-top:16px">
          <div class="topbar">
            <div class="label">Chord phase: seconds per chord</div>
            <div class="spacer"></div>
            <div class="label"><span id="lblTempo">3</span>s</div>
          </div>
          <input id="sliderChord" type="range" min="2" max="5" step="0.5" value="3" />
          <div class="label">Faster ‚Üí 2s ‚Ä¢ Slower ‚Üí 5s</div>
        </div>

        <div id="riffControls" style="margin-top:10px; display:none">
          <div class="topbar">
            <div class="label">Riff phase: seconds per riff</div>
            <div class="spacer"></div>
            <div class="label"><span id="lblRiffDur">5</span>s</div>
          </div>
          <input id="sliderRiff" type="range" min="3" max="8" step="0.5" value="5" />
          <div class="label">Riff notes auto-advance across this duration</div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
          <div class="label" style="font-size:16px; color:var(--text); font-weight:700">Chord Counters</div>
        </div>
        <div id="counterGrid" class="grid2"></div>

        <div style="margin-top:14px">
          <details>
            <summary>Chord Set</summary>
            <div class="label" style="margin-top:6px">Active set: C ‚Ä¢ G ‚Ä¢ D ‚Ä¢ A ‚Ä¢ E</div>
          </details>
        </div>
      </div>
    </div>

    <footer>¬© You ‚Äî Practice smarter.</footer>
  </div>

<script>
/* ------------------------ Configuration ------------------------ */
const CHORDS = ["C","G","D","A","E"]; // majors
const TRIADS = { C:["C","E","G"], D:["D","F#","A"], E:["E","G#","B"], G:["G","B","D"], A:["A","C#","E"] };
const TRANSITION = { stay: 0.25, next: 0.45, prev: 0.25, jump: 0.05 };
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_INDEX = Object.fromEntries(NOTE_NAMES.map((n,i)=>[n,i]));

const RIFFS = [
  [0, 4, 7, 9, 7, 4],  // R‚Äì3‚Äì5‚Äì6‚Äì5‚Äì3
  [0, 2, 4, 5, 4, 2],
  [0, 7, 5, 4, 2, 0],
  [0, 4, 7, 12, 7, 4],
  [0, 2, 4, 7, 4, 2],
  [0, 5, 7, 9, 7, 5],
  [0, 4, 2, 0, 2, 4],
  [0, 7, 9, 7, 5, 4],
  [0, 12, 7, 5, 4, 0],
  [0, 4, 7, 4, 2, 0],
];

/* ------------------------ Persistence ------------------------ */
const LSKEY = k => `chordtrainer:${k}`;
const load  = (k, def) => { try { const v = localStorage.getItem(LSKEY(k)); return v ? JSON.parse(v) : def; } catch { return def; } }
const save  = (k, v)   => { try { localStorage.setItem(LSKEY(k), JSON.stringify(v)); } catch {} }

/* ------------------------ State ------------------------ */
let instrument = load("instrument","guitar");     // "guitar" | "piano"
let mode = load("mode","chord");                  // "chord" | "chord+riff"
let secondsPerChord = load("secondsPerChord",3);
let secondsPerRiff  = load("secondsPerRiff" ,5);
let bpm = load("bpm", 90);

let running=false, paused=false;
let sessionStartPerf=null, sessionMs=0;
let nextAt=null, activeIdx=0, changes=0;
let perChordCounts = load("perChordCounts", {});
let countInOn = load("countInOn", true);
let clickOn   = load("clickOn", true);

let phase = "chord";       // "chord" | "riff"
let riffIndex = null;      // chosen riff for session
let riffNotes = [];        // current chord's riff note names
let riffStep = 0;
let riffNoteInterval = 1000;
let lastRiffNoteAt = null;

let nextPreviewIdx = null; // precomputed next chord for preview

// Metronome
let metroTimer = null, metroPeriodMs = bpmToMs(bpm);
let audioCtx = null;

/* ------------------------ UI refs ------------------------ */
const vSession = document.getElementById("vSession");
const vSub = document.getElementById("vSub");
const vTempo = document.getElementById("vTempo");
const lblTempo = document.getElementById("lblTempo");
const vNow = document.getElementById("vNow");
const vInstr = document.getElementById("vInstr");
const bigChord = document.getElementById("bigChord");
const diagram = document.getElementById("diagram");
const counterGrid = document.getElementById("counterGrid");
const progressSvg = document.getElementById("progressSvg");
const countInNum = document.getElementById("countInNum");
const riffWrap = document.getElementById("riffWrap");
const riffStrip = document.getElementById("riffStrip");
const riffTag = document.getElementById("riffTag");
const riffGraphic = document.getElementById("riffGraphic");
const nextChordEl = document.getElementById("nextChord");
const togglePreviewBtn = document.getElementById("togglePreview");
const bpmSlider = document.getElementById("bpmSlider");
const bpmVal = document.getElementById("bpmVal");
const metroDot = document.getElementById("metroDot");

/* ------------------------ Bindings ------------------------ */
document.getElementById("btnStart").onclick = onStart;
document.getElementById("btnPause").onclick = onPause;
document.getElementById("btnStop").onclick  = onStop;
document.getElementById("btnPrev").onclick  = () => stepManual(-1);
document.getElementById("btnNext").onclick  = () => stepManual(+1);
document.getElementById("btnExport").onclick= onExport;

document.getElementById("btnGuitar").onclick = () => setInstrument("guitar");
document.getElementById("btnPiano").onclick  = () => setInstrument("piano");

document.getElementById("btnChordOnly").onclick = () => setMode("chord");
document.getElementById("btnChordRiff").onclick = () => setMode("chord+riff");

document.getElementById("btnClick").onclick   = () => { clickOn = !clickOn; save("clickOn",clickOn); reflectToggles(); }
document.getElementById("btnCountIn").onclick = () => { countInOn = !countInOn; save("countInOn",countInOn); reflectToggles(); }

const sliderChord = document.getElementById("sliderChord");
sliderChord.oninput = e => { secondsPerChord = parseFloat(e.target.value); vTempo.textContent = secondsPerChord; lblTempo.textContent = secondsPerChord; save("secondsPerChord", secondsPerChord); }
const sliderRiff = document.getElementById("sliderRiff");
const lblRiffDur = document.getElementById("lblRiffDur");
sliderRiff.oninput = e => { secondsPerRiff = parseFloat(e.target.value); lblRiffDur.textContent = secondsPerRiff; save("secondsPerRiff", secondsPerRiff); recomputeRiffInterval(); }

bpmSlider.oninput = e => { bpm = parseInt(e.target.value,10); bpmVal.textContent = bpm; save("bpm", bpm); restartMetronome(); };

let previewMode = load("previewMode","show"); // "show" | "blur" | "hide"
togglePreviewBtn.onclick = cyclePreviewMode;

/* ------------------------ Metronome ------------------------ */
function bpmToMs(b){ return 60000/Math.max(40,Math.min(140,b)); }
function restartMetronome(){
  if (metroTimer) { clearInterval(metroTimer); metroTimer = null; }
  metroPeriodMs = bpmToMs(bpm);
  if (running){
    metroTimer = setInterval(()=> {
      blink();
      if (clickOn) click();
    }, metroPeriodMs);
  }
}
function blink(){
  metroDot.classList.add("active");
  setTimeout(()=>metroDot.classList.remove("active"), Math.min(120, metroPeriodMs*0.3));
}
function click(){
  if (!clickOn) return;
  try{
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const t = audioCtx.currentTime + 0.01;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type="sine"; o.frequency.value = 880;
    g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(0.25, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
    o.connect(g).connect(audioCtx.destination);
    o.start(t); o.stop(t+0.09);
  }catch{}
}

/* ------------------------ Init / UI ------------------------ */
function reflectToggles(){
  const g = document.getElementById("btnGuitar"), p = document.getElementById("btnPiano");
  g.style.background = (instrument==="guitar") ? "#fff" : "var(--card2)"; g.style.color = (instrument==="guitar") ? "#000" : "var(--text)";
  p.style.background = (instrument==="piano")  ? "#fff" : "var(--card2)"; p.style.color = (instrument==="piano")  ? "#000" : "var(--text)";

  const b1 = document.getElementById("btnChordOnly"), b2 = document.getElementById("btnChordRiff");
  b1.style.background = (mode==="chord") ? "#fff" : "var(--card2)"; b1.style.color = (mode==="chord") ? "#000" : "var(--text)";
  b2.style.background = (mode==="chord+riff") ? "#fff" : "var(--card2)"; b2.style.color = (mode==="chord+riff") ? "#000" : "var(--text)";

  const c1 = document.getElementById("btnClick"), c2 = document.getElementById("btnCountIn");
  c1.style.background = clickOn ? "#fff" : "var(--card2)"; c1.style.color = clickOn ? "#000" : "var(--text)";
  c2.style.background = countInOn ? "#fff" : "var(--card2)"; c2.style.color = countInOn ? "#000" : "var(--text)";

  riffTag.style.display = (mode==="chord+riff" && riffIndex!=null) ? "" : "none";
  if (riffIndex!=null) riffTag.textContent = `Riff ${riffIndex+1}`;

  bpmVal.textContent = bpm;
  bpmSlider.value = String(bpm);

  // preview mode UI text and effect
  togglePreviewBtn.textContent = "Preview: " + (previewMode==="show" ? "Show" : (previewMode==="blur" ? "Blur" : "Hide"));
  nextChordEl.style.visibility = (previewMode==="hide") ? "hidden" : "visible";
  nextChordEl.classList.toggle("blurred", previewMode==="blur");

  document.getElementById("riffControls").style.display = mode==="chord+riff" ? "" : "none";
}
function setInstrument(modeName){
  instrument = modeName; save("instrument", instrument);
  updateCurrentVisuals(); renderCounters(); reflectToggles();
}
function setMode(newMode){
  mode = newMode; save("mode", mode);
  if (mode==="chord+riff" && riffIndex==null) chooseRiffForSession();
  reflectToggles();
}
function cyclePreviewMode(){
  previewMode = (previewMode==="show") ? "blur" : (previewMode==="blur" ? "hide" : "show");
  save("previewMode", previewMode);
  reflectToggles();
}
function chooseRiffForSession(){
  riffIndex = Math.floor(Math.random()*RIFFS.length);
}
function recomputeRiffInterval(){
  const patsz = (riffIndex!=null) ? RIFFS[riffIndex].length : 1;
  riffNoteInterval = (secondsPerRiff * 1000) / Math.max(patsz,1);
}

/* ------------------------ Rendering ------------------------ */
function renderCounters(){
  counterGrid.innerHTML = "";
  CHORDS.forEach((c, idx) => {
    const wrap = document.createElement("div");
    wrap.className = "card"; if (idx===activeIdx) wrap.style.background = "var(--card2)";
    const head = document.createElement("div");
    head.style.display="flex"; head.style.justifyContent="space-between"; head.style.alignItems="center";
    head.innerHTML = `<div style="font-size:20px; font-weight:700">${c}</div><div class="count">${perChordCounts[c] ?? 0}</div>`;
    const svgDiv = document.createElement("div"); svgDiv.className = "svg-wrap"; svgDiv.style.marginTop="8px";
    svgDiv.appendChild( instrument==="guitar" ? guitarChordSvg(c) : pianoChordSvg(c) );
    wrap.appendChild(head); wrap.appendChild(svgDiv);
    counterGrid.appendChild(wrap);
  });
}
function updateCurrentVisuals(){
  const name = CHORDS[activeIdx];
  vNow.textContent = name; bigChord.textContent = name;
  diagram.innerHTML = ""; diagram.appendChild( instrument==="guitar" ? guitarChordSvg(name) : pianoChordSvg(name));
  if (mode==="chord+riff" && riffIndex!=null){
    riffNotes = makeRiffNotes(name, RIFFS[riffIndex]);
    buildRiffStrip();
    renderRiffGraphic(); // reset for current chord
  }
  // compute and show next preview (actual scheduled next)
  nextPreviewIdx = computeNextIdx(activeIdx); // preview based on same Markov weights
  nextChordEl.textContent = CHORDS[nextPreviewIdx];
}
function buildRiffStrip(){
  riffStrip.innerHTML = "";
  riffNotes.forEach((n, i)=>{
    const span = document.createElement("div");
    span.className = "riff-note" + (i===riffStep ? " active" : "");
    span.textContent = n;
    riffStrip.appendChild(span);
  });
}
function renderRiffGraphic(activeNoteIndex = 0){
  riffGraphic.innerHTML = "";
  const noteName = riffNotes[activeNoteIndex] || riffNotes[0] || null;
  if (!noteName) return;
  const svg = (instrument==="piano")
    ? pianoKeyboardWithActive(noteName)
    : guitarMiniFretboard(noteName);
  riffGraphic.appendChild(svg);
}

/* ------------------------ Timing ------------------------ */
function fmtTime(ms){
  const total = Math.floor(ms/1000); const h = Math.floor(total/3600);
  const m = Math.floor((total%3600)/60); const s = total%60;
  const hh = h>0 ? h + ":" : ""; return hh + String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
}
function tick(now){
  if (!running || paused){ requestAnimationFrame(tick); return; }
  if (sessionStartPerf!=null) sessionMs = now - sessionStartPerf;

  if (nextAt==null){
    scheduleNext(now, true);
  } else if (now >= nextAt){
    if (mode==="chord+riff"){
      if (phase==="chord"){
        phase = "riff";
        riffStep = 0; lastRiffNoteAt = now;
        scheduleNext(now, false);
      } else {
        phase = "chord";
        advanceChord();
        scheduleNext(now, false);
      }
    } else {
      advanceChord();
      scheduleNext(now, false);
    }
  }

  // advance current riff note inside riff phase
  if (mode==="chord+riff" && phase==="riff" && riffIndex!=null){
    const len = RIFFS[riffIndex].length;
    if (now - lastRiffNoteAt >= riffNoteInterval){
      riffStep = Math.min(riffStep+1, len-1);
      lastRiffNoteAt = now;
      // update strip + graphic
      const kids = riffStrip.children;
      for (let i=0;i<kids.length;i++){
        kids[i].className = "riff-note" + (i===riffStep ? " active" : "");
      }
      renderRiffGraphic(riffStep);
    }
  }

  // UI
  vSession.textContent = fmtTime(sessionMs);
  const cpm = sessionMs>0 ? (changes / (sessionMs/60000)).toFixed(1) : "0.0";
  vSub.textContent = `${changes} changes ‚Ä¢ ${cpm} cpm`;
  drawProgress(now);
  requestAnimationFrame(tick);
}
function scheduleNext(now, first){
  const dur = (mode==="chord+riff")
    ? (phase==="chord" ? secondsPerChord*1000 : secondsPerRiff*1000)
    : (secondsPerChord*1000);
  nextAt = now + dur;

  // Count-in only once at session start
  if (first && countInOn){
    let n = 3; countInNum.style.display="block"; countInNum.textContent=n;
    const id = setInterval(()=>{
      n -= 1;
      if (n<=0){ countInNum.style.display="none"; clearInterval(id); }
      else { countInNum.textContent = n; }
    },1000);
  }

  // Riff UI visibility per phase
  riffWrap.style.display = (mode==="chord+riff" && phase==="riff") ? "" : "none";

  // When entering a chord phase, compute preview of the *next* chord that will follow
  if (phase==="chord"){
    nextPreviewIdx = computeNextIdx(activeIdx);
    nextChordEl.textContent = CHORDS[nextPreviewIdx];
  }
}
function computeNextIdx(i){
  // deterministic preview using one random draw at schedule time
  const w = TRANSITION; const r = Math.random();
  if (r < w.stay) return i;
  if (r < w.stay + w.next) return (i+1)%CHORDS.length;
  if (r < w.stay + w.next + w.prev) return (i-1+CHORDS.length)%CHORDS.length;
  return (i+2)%CHORDS.length;
}
function advanceChord(){
  activeIdx = nextPreviewIdx ?? computeNextIdx(activeIdx); // use previewed next when available
  changes++;
  const id = CHORDS[activeIdx]; perChordCounts[id] = (perChordCounts[id]||0)+1; save("perChordCounts", perChordCounts);
  updateCurrentVisuals(); renderCounters();
}
function stepManual(dir){
  if (running && !paused) return;
  activeIdx = (activeIdx + dir + CHORDS.length) % CHORDS.length;
  updateCurrentVisuals(); renderCounters();
}

/* ------------------------ Controls ------------------------ */
function onStart(){
  if (running && !paused) return;
  if (!running && mode==="chord+riff"){
    if (riffIndex==null) chooseRiffForSession();
    riffStep = 0; recomputeRiffInterval(); phase = "chord";
  }
  running = true; paused = false;
  if (sessionStartPerf===null) sessionStartPerf = performance.now();
  scheduleNext(performance.now(), true);
  restartMetronome();
}
function onPause(){
  if (!running) return;
  paused = !paused;
  if (paused && metroTimer){ clearInterval(metroTimer); metroTimer=null; }
  if (!paused) restartMetronome();
}
function onStop(){
  running=false; paused=false; nextAt=null; sessionStartPerf=null; sessionMs=0; changes=0; perChordCounts={}; save("perChordCounts", perChordCounts);
  phase = "chord"; riffIndex=null; riffNotes=[]; riffStep=0;
  vSession.textContent="0:00"; vSub.textContent="0 changes ‚Ä¢ 0.0 cpm";
  riffWrap.style.display="none"; renderCounters(); drawProgress(performance.now()); reflectToggles();
  if (metroTimer){ clearInterval(metroTimer); metroTimer=null; }
}
function onExport(){
  const rows = [
    ["Chord","Count"], ...CHORDS.map(c=>[c, String(perChordCounts[c]||0)]),
    ["Total Changes", String(changes)],
    ["Session Seconds", String(Math.round(sessionMs/1000))],
    ["Instrument", instrument],
    ["Mode", mode],
    ["Seconds Per Chord", String(secondsPerChord)],
    ["Seconds Per Riff", String(secondsPerRiff)],
    ["Riff Index", riffIndex!=null ? String(riffIndex+1) : "-"],
    ["Riff Pattern (semitones)", riffIndex!=null ? RIFFS[riffIndex].join(" ") : "-"],
    ["BPM", String(bpm)],
    ["Preview Mode", previewMode]
  ];
  const csv = rows.map(r=>r.map(v=>`"${v}"`).join(",")).join("\n");
  const blob = new Blob([csv],{type:"text/csv"}); const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href=url; a.download=`practice-${instrument}-${new Date().toISOString().slice(0,19)}.csv`; a.click(); URL.revokeObjectURL(url);
}

// Keyboard shortcuts
window.addEventListener("keydown", e=>{
  if (e.code==="Space"){ e.preventDefault(); running?onPause():onStart(); }
  else if (e.key.toLowerCase()==="s"){ onStop(); }
  else if (e.key==="ArrowRight"){ stepManual(+1); }
  else if (e.key==="ArrowLeft"){ stepManual(-1); }
});

/* ------------------------ Music helpers ------------------------ */
function makeRiffNotes(chordName, offsets){
  const rootIdx = NOTE_INDEX[chordName];
  return offsets.map(semi => NOTE_NAMES[(rootIdx + semi + 120)%12]);
}

/* ------------------------ SVG helpers & Graphics ------------------------ */
function el(tag, attrs={}, text){
  const n = document.createElementNS("http://www.w3.org/2000/svg", tag);
  Object.entries(attrs).forEach(([k,v])=>n.setAttribute(k, String(v)));
  if (text!=null) n.appendChild(document.createTextNode(text));
  return n;
}

/* ---- Chord diagrams (with clear labels) ---- */
function guitarChordSvg(name){
  // Open major shapes (visual cue)
  const dots = { A:[{f:2,s:5},{f:2,s:4},{f:2,s:3}], E:[{f:2,s:5},{f:2,s:4},{f:1,s:3}], G:[{f:3,s:6},{f:2,s:5},{f:3,s:1}], D:[{f:2,s:3},{f:3,s:2},{f:2,s:1}], C:[{f:3,s:5},{f:2,s:4},{f:1,s:2}] };
  const open = {A:[5,2,1], E:[6,2,1], G:[4,3,2], D:[4], C:[3]};
  const mute = {A:[6], E:[], G:[], D:[6,5], C:[6]};
  const d = dots[name]||[], o=open[name]||[], m=mute[name]||[];
  const W=160,H=190,pX=18,pY=28,strings=6,frets=5,sx=(W-pX*2)/(strings-1),fy=(H-pY*2)/frets;
  const stringX = s => pX + (s-1)*sx, fretY=f=> pY+f*fy;
  const svg = el("svg",{viewBox:`0 0 ${W} ${H}`,width:132,height:158});
  // Title banner
  const label = `${name} major`;
  svg.appendChild(el("rect",{x:W/2-60,y:6,width:120,height:18,fill:"rgba(0,0,0,.55)",rx:6}));
  svg.appendChild(el("text",{x:W/2,y:20,"text-anchor":"middle","dominant-baseline":"middle",fill: "var(--accent)","font-weight":"700"},label));
  // Nut & grid
  svg.appendChild(el("rect",{x:pX-3,y:pY-6,width:W-2*(pX-3),height:6,fill:"#fff"}));
  for(let i=0;i<strings;i++){ svg.appendChild(el("line",{x1:stringX(i+1),y1:pY,x2:stringX(i+1),y2:H-pY,stroke:"#fff","stroke-width":1})); }
  for(let f=1;f<=frets;f++){ svg.appendChild(el("line",{x1:pX,y1:fretY(f),x2:W-pX,y2:fretY(f),stroke:"#fff","stroke-width":1})); }
  d.forEach(({f,s})=> svg.appendChild(el("circle",{cx:stringX(s),cy:pY+(f-0.5)*fy,r:7,fill:"#fff"})));
  for(let i=0;i<strings;i++){
    const s=i+1, cx=stringX(s), cy=pY-12;
    if (m.includes(s)){ svg.appendChild(el("line",{x1:cx-5,y1:cy-5,x2:cx+5,y2:cy+5,stroke:"#fff","stroke-width":2})); svg.appendChild(el("line",{x1:cx+5,y1:cy-5,x2:cx-5,y2:cy+5,stroke:"#fff","stroke-width":2})); }
    else if (o.includes(s)){ svg.appendChild(el("circle",{cx,cy,r:5,fill:"none",stroke:"#fff","stroke-width":2})); }
  }
  return svg;
}
function pianoChordSvg(name){
  const triad = TRIADS[name] || [];
  const W=300, H=160, keyH=125;
  const whiteOrder=["C","D","E","F","G","A","B","C","D","E","F","G","A","B"];
  const blackAfter = {C:"C#", D:"D#", E:null, F:"F#", G:"G#", A:"A#", B:null};
  const wW=W/whiteOrder.length, bW=wW*0.6, bH=keyH*0.62;
  const svg = el("svg",{viewBox:`0 0 ${W} ${H}`, width:320, height:170});
  // white keys
  whiteOrder.forEach((w,i)=>{
    svg.appendChild(el("rect",{x:i*wW,y:0,width:wW,height:keyH,fill:"#fff",stroke:"#000","stroke-width":0.6,opacity:.95}));
    if (triad.includes(w)){
      const rx=i*wW+3, ry=keyH-24, rw=wW-6, rh=20;
      svg.appendChild(el("rect",{x:rx,y:ry,width:rw,height:rh,fill:"var(--purple)",opacity:.95,rx:3}));
      svg.appendChild(el("text",{x:rx+rw/2,y:ry+rh/2+1,"text-anchor":"middle","dominant-baseline":"middle",fill:"#fff","font-weight":"700"},w));
    }
  });
  // black keys
  whiteOrder.forEach((w,i)=>{
    const acc = blackAfter[w]; if (!acc) return;
    const x=i*wW+wW-bW/2;
    svg.appendChild(el("rect",{x,y:0,width:bW,height:bH,fill:"#000",stroke:"#222","stroke-width":0.6}));
    if (triad.includes(acc)){
      const rx=x+3, ry=bH-18, rw=bW-6, rh=15;
      svg.appendChild(el("rect",{x:rx,y:ry,width:rw,height:rh,fill:"#fff",opacity:.95,rx:2}));
      svg.appendChild(el("text",{x:rx+rw/2,y:ry+rh/2+1,"text-anchor":"middle","dominant-baseline":"middle",fill:"var(--purple)","font-weight":"700"},acc));
    }
  });
  // chord banner
  const label = `${name} major`;
  svg.appendChild(el("rect",{x:W/2-70,y:keyH+6,width:140,height:22,fill:"rgba(0,0,0,.55)",rx:6}));
  svg.appendChild(el("text",{x:W/2,y:keyH+6+11,"text-anchor":"middle","dominant-baseline":"middle",fill:"var(--accent)","font-weight":"700"},label));
  return svg;
}

/* ---- Riff graphics ---- */
// Piano: keyboard with a single active note highlighted
function pianoKeyboardWithActive(noteName){
  const W=300, H=120, keyH=110;
  const whiteOrder=["C","D","E","F","G","A","B","C","D","E","F","G","A","B"];
  const blackAfter = {C:"C#", D:"D#", E:null, F:"F#", G:"G#", A:"A#", B:null};
  const wW=W/whiteOrder.length, bW=wW*0.6, bH=keyH*0.62;
  const svg = el("svg",{viewBox:`0 0 ${W} ${H}`, width:320, height:130});
  // white keys
  whiteOrder.forEach((w,i)=>{
    svg.appendChild(el("rect",{x:i*wW,y:0,width:wW,height:keyH,fill:"#fff",stroke:"#000","stroke-width":0.6,opacity:.95}));
    if (w===noteName){
      const rx=i*wW+2, rw=wW-4;
      svg.appendChild(el("rect",{x:rx,y:2,width:rw,height:keyH-4,fill:"var(--accent)",opacity:.25,rx:3}));
      svg.appendChild(el("text",{x:i*wW+wW/2,y:keyH-16,"text-anchor":"middle","dominant-baseline":"middle",fill:"#000","font-weight":"800"},w));
    }
  });
  // black keys
  whiteOrder.forEach((w,i)=>{
    const acc = blackAfter[w]; if (!acc) return;
    const x=i*wW+wW-bW/2;
    svg.appendChild(el("rect",{x,y:0,width:bW,height:bH,fill:"#000",stroke:"#222","stroke-width":0.6}));
    if (acc===noteName){
      svg.appendChild(el("rect",{x:x+2,y:2,width:bW-4,height:bH-4,fill:"var(--accent)",opacity:.8,rx:2}));
      svg.appendChild(el("text",{x:x+bW/2,y:bH-10,"text-anchor":"middle","dominant-baseline":"middle",fill:"#3b1e75","font-weight":"800"},acc));
    }
  });
  return svg;
}

// Guitar: compact 6x7 fretboard, highlight one playable position for the note
// Standard tuning E2 A2 D3 G3 B3 E4 (mod 12 for pitch class)
const OPEN_PC = [4,9,2,7,11,4]; // E A D G B E -> [E,F#,G#...]= actually pitch classes: E=4,A=9,D=2,G=7,B=11,E=4
function guitarMiniFretboard(noteName){
  const target = NOTE_INDEX[noteName];
  // Find a low-fret placement (0..7) preferring middle strings to be ergonomic
  const stringOrder = [5,4,3,2,1,0]; // favor middle (D,G,B), then A/E
  let place = null;
  for (const s of stringOrder){
    for (let f=0; f<=7; f++){
      if ((OPEN_PC[s] + f) % 12 === target){ place = {s, f}; break; }
    }
    if (place) break;
  }
  // default fallback
  if (!place) place = {s:3, f:0};

  const W=260, H=110, padX=20, padY=12, strings=6, frets=7;
  const sx=(W-padX*2)/(frets), sy=(H-padY*2)/(strings-1); // horizontal frets, vertical strings
  const stringY = s => padY + (s)*sy;
  const fretX = f => padX + f*sx;

  const svg = el("svg",{viewBox:`0 0 ${W} ${H}`, width:300, height:130});
  // Frets
  for(let f=0; f<=frets; f++){
    svg.appendChild(el("line",{x1:fretX(f),y1:padY,x2:fretX(f),y2:H-padY,stroke:"#fff","stroke-width":f===0?3:1,opacity:f===0?1:.9}));
  }
  // Strings
  for(let s=0; s<strings; s++){
    svg.appendChild(el("line",{x1:padX,y1:stringY(s),x2:W-padX,y2:stringY(s),stroke:"#fff","stroke-width": (s===0||s===5)?2:1,opacity:.9}));
  }
  // Note dot
  svg.appendChild(el("circle",{cx:fretX(place.f)+sx/2, cy:stringY(place.s), r:8, fill:"var(--accent)"}));
  // Label
  svg.appendChild(el("rect",{x:W/2-60,y:H-22,width:120,height:18,fill:"rgba(0,0,0,.55)",rx:6}));
  svg.appendChild(el("text",{x:W/2,y:H-13,"text-anchor":"middle","dominant-baseline":"middle",fill:"#fff","font-weight":"700"}, noteName));
  return svg;
}

/* ---- Progress ring ---- */
function drawProgress(now){
  const total = (mode==="chord+riff")
    ? (phase==="chord" ? secondsPerChord*1000 : secondsPerRiff*1000)
    : (secondsPerChord*1000);
  const left = Math.max((nextAt??now)-now, 0);
  const p = 1 - left/total;

  progressSvg.innerHTML = "";
  const size=200, radius=90, stroke=10, c=2*Math.PI*radius, dash=c*Math.min(Math.max(p,0),1);
  const svg = el("svg",{width:size,height:size});
  svg.appendChild(el("circle",{cx:size/2,cy:size/2,r:radius,stroke:"rgba(255,255,255,.25)","stroke-width":stroke,fill:"none"}));
  const fg = el("circle",{cx:size/2,cy:size/2,r:radius,stroke:"#fff","stroke-width":stroke,fill:"none","stroke-dasharray":`${dash} ${c}`,transform:`rotate(-90 ${size/2} ${size/2})`});
  fg.setAttribute("stroke-linecap","round"); svg.appendChild(fg);

  const label = (mode==="chord+riff")
    ? (phase==="chord" ? `Chord ‚Ä¢ ~${secondsPerChord}s` : `Riff ‚Ä¢ ~${secondsPerRiff}s`)
    : `Chord ‚Ä¢ ~${secondsPerChord}s`;
  svg.appendChild(el("text",{x:"50%",y:"52%","text-anchor":"middle","dominant-baseline":"middle",fill:"#fff",opacity:.9},label));

  progressSvg.appendChild(svg);
}

/* ------------------------ Boot ------------------------ */
function boot(){
  document.getElementById("vTempo").textContent = secondsPerChord;
  document.getElementById("lblTempo").textContent = secondsPerChord;
  document.getElementById("lblRiffDur").textContent = secondsPerRiff;
  document.getElementById("sliderChord").value = String(secondsPerChord);
  document.getElementById("sliderRiff").value  = String(secondsPerRiff);
  bpmVal.textContent = bpm; bpmSlider.value = String(bpm);

  if (mode==="chord+riff" && riffIndex==null) chooseRiffForSession();
  recomputeRiffInterval();

  reflectToggles();
  updateCurrentVisuals();
  renderCounters();
  drawProgress(performance.now());
  requestAnimationFrame(tick);
}
boot();
</script>
</body>
</html>

